'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var initShader = function (gl, type, source) {
    var shader = gl.createShader(type);
    if (shader) {
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' +
                gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
};

var initShaderProgram = function (gl, vsSource, fsSource) {
    var vsShader = initShader(gl, gl.VERTEX_SHADER, vsSource);
    var fsShader = initShader(gl, gl.FRAGMENT_SHADER, fsSource);
    var program = gl.createProgram();
    if (program) {
        if (vsShader && fsShader) {
            gl.attachShader(program, vsShader);
            gl.attachShader(program, fsShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' +
                    gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
    }
};

var loadShaderFile = function (file) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.onload = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                resolve(xhr.responseText);
            }
            reject('request shader file error');
        };
        xhr.open('GET', file);
        xhr.send();
    });
};

var initBuffer = function (gl, bufferTarget, typedData) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferTarget, buffer);
    gl.bufferData(bufferTarget, typedData, gl.STATIC_DRAW);
    return buffer;
};

exports.initBuffer = initBuffer;
exports.initShaderProgram = initShaderProgram;
exports.loadShaderFile = loadShaderFile;
